#!/usr/bin/env bash
######################
## System functions ##
######################
showIPS() {
  local x ip
  for x in $(ipconfig getiflist); do
    ip="$(ipconfig getifaddr $x)"
    if [[ -n ${ip:+x} ]]; then
      printf '%-7s %s\n' "$x:" "${ip}"
    fi
  done | sort
}
# Change working directory to the top-most Finder window location
cdf() { # short for `cdfinder`
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

finder() {
  osascript -e "tell application \"Finder\" to open POSIX file \"${@:-$PWD}\""
}

appID() { osascript -e "id of app \"$@\""; }

addHOST() {
  local varIn=($@)
  local ip=${varIn[0]}
  local entry=${varIn[@]:1}
  while [[ -z $ip ]]; do
    read -ep "What is the IP of the host you would like to add an entry for? " ip
  done
  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    local OIFS=$IFS
    local IFS='.'
    local ipTest=($ip)
    local IFS=$OIFS
    [[ ${ipTest[0]} -le 255 && ${ipTest[1]} -le 255 &&
      ${ipTest[2]} -le 255 && ${ipTest[3]} -le 255 ]]
    local valid=$?
    local unset OIFS IFS
  fi
  if [[ $valid != 0 ]]; then
    echo "$ip is not a valid IP."
    addHost
  fi
  while [[ -z $entry ]]; do
    read -ep "What is the entry you would like to add for this host? " entry
  done
  printf "%-22s%s\n" "Entry: $ip" "$entry"
  echo "Would you like to add this entry to /etc/hosts? "
  if ! menu no yes; then
    printf "%-16s%s\n" "$ip" "$entry" | sudo tee -a /etc/hosts >/dev/null 2>&1
  else
    echo "Entry will not be added."
  fi
}

###################
## Git functions ##
###################
makePullRequest() {
  local msg prOut prURL openURL
  msg="${@}"
  until [[ -n "${msg:+x}" ]]; do
    read -ep "${Y}Commit message: ${RS}" msg
  done
  echo "${B}Would you like to open this PR in your default browser?${RS}"
  menu no yes || openURL=true
  git add .
  git commit -m "${msg}"
  prOut="$(git push 2>&1)"
  echo "${prOut}"
  prURL="$(echo "${prOut}" | sed -E '/https:.*merge_requests/!d;s/^.*(https:\/\/[^ ]*).*$/\1/')"
  if [[ "${openURL}" == true ]] && [[ -n "${prURL:+x}" ]]; then
    open "$(printf '%b' "${prURL//%/\\x}")"
  elif [[ "${openURL}" == true ]] && [[ -z "${prURL:+x}" ]]; then
    echo "${R}No PR URL found.${RS}" >&2
  fi
}

gitOpenRepo() {
  local gitDir repoName repoDir repoSubDir friendlyName
  gitDir="${HOME}/repos" repoName="${1:?No repo specified}"
  repoDir="$(dirname $(find "${gitDir}" -type d -name ".git" -path "*/${repoName}/*") 2>/dev/null)"
  [[ -d "${repoDir}" ]] || (
    echo "No repo named '${repoName}' was found."
    return
  )

  if [[ -n "${2}" && -d "${repoDir}/${2}" ]]; then
    repoSubDir="${2}" friendlyName="${@:3}"
  elif [[ -n "${2}" ]]; then
    friendlyName="${@:2}"
  fi

  echo "Opening the ${B}${friendlyName:-${repoName}}${RS} repository..."
  cd "${repoDir}/${repoSubDir}"
}

####################
## Text functions ##
####################
joinBY() {
  local IFS=$1
  shift
  echo "$*"
}
decryptTEXT() {
  local input=$(pbpaste | sed 's/^[ ]*//')
  local clearText=$(echo -n "$input" | sed 's/^[ ]*//' | gpg -dq - 2>/dev/null)
  if [[ -z "$clearText" ]]; then
    read -ep "${YELLOW}Please copy gpg text to clipboard and press enter when ready.${RESET}"
    local input=$(pbpaste | sed 's/^[ ]*//')
  fi
  local clearText=$(gpg -dq - 2>/dev/null <<<"$input")
  local gpgKeysFull=$({ sed 's/^[ ]*//' <<<"$input" | gpg -d -; } 2>&1)
  local gpgKeys=$(grep -A1 'gpg: encrypted' <<<"$gpgKeysFull" | sed '/^ /!d;s/^ *//;s/"//g')
  if [[ -z "$clearText" ]]; then
    echo "Invalid gpg text provided. Please try again."
  else
    echo
    echo "${BLUE}##################################################${RESET}"
    echo "${RED}Encryption ${BLUE}-> ${GREEN}Decryption ${BLUE}verification shown below${RESET}"
    echo "${BLUE}##################################################${RESET}"
    echo
    echo "$clearText"
    echo
    echo "${BLUE}##################################################${RESET}"
    echo "${RED}Keys used to decrypt secret text listed below${RESET}"
    echo "${BLUE}##################################################${RESET}"
    echo
    echo "${GREEN}$gpgKeys${RESET}"
    echo
    echo "${BLUE}##################################################${RESET}"
    echo
    echo "${BLUE}Would you like to copy decrypted text to clipboard?${RESET}"
    if menu yes no; then
      pbcopy <<<"$clearText"
      echo "${GREEN}Decrypted text has been copied to clipboard!${RESET}"
    else
      echo "${YELLOW}Decrypted text was NOT copied.${RESET}"
    fi
  fi
}

filterPGP() {
  decryptSECRET() {
    local clearText=$(echo -n "${1}" | sed 's/^[ ]*//' | gpg -dq - 2>/dev/null)
    local gpgKeysFull=$({ sed 's/^[ ]*//' <<<"${1}" | gpg -d -; } 2>&1)
    local gpgKeys=$(grep -A1 'gpg: encrypted' <<<"${gpgKeysFull}" | sed '/^ /!d;s/^ *//;s/"//g')
    if [[ -n "${clearText}" ]]; then
      echo
      echo "${BLUE}##################################################${RESET}"
      echo "${RED}Encryption ${BLUE}-> ${GREEN}Decryption ${BLUE}verification shown below${RESET}"
      echo "${BLUE}##################################################${RESET}"
      echo
      echo "${clearText}"
      echo
      echo "${BLUE}##################################################${RESET}"
      echo "${RED}Keys used to decrypt secret text listed below${RESET}"
      echo "${BLUE}##################################################${RESET}"
      echo "${GREEN}${gpgKeys}${RESET}"
      echo "${BLUE}##################################################${RESET}"
      echo
    fi
  }
  local file=$1
  local block=()
  local secrets=()
  while [[ -z ${file} || ! -f ${file} ]]; do
    read -ep "${GREEN}File path to decrypt: ${RESET}" file
    [[ ! -f ${file} ]] && {
      echo "${RED}'${file}' is not a valid file path${RESET}"
      unset file
    }
  done
  local IFS=$'\n'
  local lines=($(cat ${file}))
  for line in ${lines[@]}; do
    if [[ ${line} == *"-----BEGIN"* ]]; then
      block+=(${line})
      local inProg=True
    elif [[ ${inProg} == True ]]; then
      block+=(${line})
      if [[ ${line} == *"-----END"* ]]; then
        decryptSECRET "${block[*]}"
        unset inProg
        local block=()
      fi
    fi
  done
}

###################
## Menu function ##
###################
menu() {
  local ESC=$(printf "\033")
  cursor_blink_on() { printf "$ESC[?25h"; }
  cursor_blink_off() { printf "$ESC[?25l"; }
  cursor_to() { printf "$ESC[$1;${2:-1}H"; }
  print_option() { printf "   $1 "; }
  print_selected() { printf "  $ESC[7m $1 $ESC[27m"; }
  get_cursor_row() {
    IFS=';' read -sdR -p $'\E[6n' ROW COL
    echo ${ROW#*[}
  }
  key_input() {
    read -s -n3 key 2>/dev/null >&2
    if [[ $key = "$ESC[A" ]]; then echo up; fi
    if [[ $key = "$ESC[B" ]]; then echo down; fi
    if [[ $key = "" ]]; then echo enter; fi
  }
  for opt; do printf "\n"; done
  local lastrow=$(get_cursor_row)
  local startrow=$(($lastrow - $#))
  cursor_blink_off
  local selected=0
  while true; do
    printf "\n"
    local idx=0
    for opt; do
      cursor_to $(($startrow + $idx))
      if [ $idx -eq $selected ]; then
        print_selected "$opt"
      else
        print_option "$opt"
      fi
      ((idx++))
    done
    case $(key_input) in
    enter) break ;;
    up)
      ((selected--))
      if [ $selected -lt 0 ]; then local selected=$(($# - 1)); fi
      ;;
    down)
      ((selected++))
      if [ $selected -ge $# ]; then local selected=0; fi
      ;;
    esac
  done
  cursor_to $lastrow
  printf "\n"
  cursor_blink_on
  return $selected
}

####################
## Misc functions ##
####################
vagrantSSH() {
  [[ -n $1 ]] && echo "${GREEN}Initiating SSH session with Vagrant node $host...${RESET}"
  vagrant ssh $1 -c 'sudo -i'
}

windowTITLE() { echo -ne "\033]0;"$*"\007"; }

randPASS() { env LC_CTYPE=C tr -dc "a-zA-Z0-9-_\$\?" </dev/urandom | head -c ${1:-24}; }

genPASS() {
  local pass=$(randPASS $1)
  echo "${pass}"
  echo -e "\n${BLUE}Would you like to copy password to clipboard?${RESET}"
  menu yes no && pbcopy <<<"${pass}"
}

getCERT() {
  for site in "$@"; do
    timeout 5 openssl s_client -showcerts -servername $site -connect $site </dev/null
  done
}

dockerCLEAN() { docker stop $1 && docker rm $1; }

sshGCP() {
  local server="usctr-prod-${1#*-*-}"
  local IP=$(ssh -q 10.112.8.3 "host $server" | sed 's/.* //')
  ss $IP
}

controlCHROME() {
  local windowType=NORMAL
  windowNORMAL() {
    if [[ $close == true ]]; then
      osascript <<EOF
tell application "Google Chrome"
  close (every window whose mode is not "incognito")
end tell
EOF
    else
      osascript <<EOF
tell application "Google Chrome"
  make new window
end tell
EOF
    fi
  }
  windowINCOGNITO() {
    if [[ $close == true ]]; then
      osascript <<EOF
tell application "Google Chrome"
  close (every window whose mode is "incognito")
end tell
EOF
    else
      osascript <<EOF
tell application "Google Chrome"
  make new window with properties {mode:"incognito"}
end tell
EOF
    fi
  }
  closeALL() {
    osascript <<EOF
tell application "Google Chrome"
  close every window
end tell
EOF
  }
  while test $# -gt 0; do
    case "$1" in
    -c | --close)
      shift
      local close=true
      ;;
    -i | --incognito)
      shift
      local windowType=INCOGNITO
      ;;
    --close-all)
      shift
      local windowType=ALL
      closeALL >/dev/null
      ;;
    *)
      echo "${RED}'$1' is not a valid parameter.${RESET}"
      ;;
    esac
  done
  [[ "$windowType" != "ALL" ]] && eval window$windowType >/dev/null
}

updateSaltRepo() {
  local saltMaster branch defBranch currBranch
  saltMaster=${1%-salt*}-salt01 defBranch='master' currBranch="$(git branch 2>/dev/null | sed '/^\* /!d;s/^\* //')"
  if [[ -n ${2} ]]; then
    if [[ -n $(perl -pe 's/(disable|enable)?.*/$1/i' <<<"${2}") ]]; then
      echo "${Y}${2%e}ing Salt scheduled jobs...${RS}"
      ssh -tq ${saltMaster} "sudo salt-call schedule.${2}"
      return
    else
      branch=${2}
    fi
  elif [[ -z ${branch} ]] && [[ -n "${currBranch}" ]] && [[ ${currBranch} != "master" ]]; then
    echo "${B}Which branch would you like to checkout on the master?${RS}"
    if menu ${defBranch} ${currBranch}; then
      branch=${defBranch}
    else
      branch=${currBranch}
    fi
  else
    branch=${defBranch}
  fi
  if [[ -n ${saltMaster} ]]; then
    echo "${GREEN}Pulling latest updates from the '${branch}' branch on ${saltMaster}.${RESET}"
    ssh -tq ${saltMaster} "cd /srv/salt; sudo git pull; sudo git checkout ${branch}; sudo git pull"
  else
    echo "${RED}No salt master was provided.${RESET}"
  fi
}

updateAllSaltRepos() { for x in ut-prod hq-prod hq-stage hq-dev; do updateSaltRepo ${x} ${1:-master}; done; }

restartMinionService() {
  local saltMaster=${1%-salt*}-salt01
  shift
  local minion=$1
  shift
  local service=$1
  if [[ -n ${saltMaster} && -n ${minion} && -n ${service} ]]; then
    echo "${GREEN}Restarting service on minion '${minion}' from ${saltMaster}.${RESET}"
    ssh -tq ${saltMaster} "sudo salt '${minion}' service.restart ${service}"
  else
    echo "${RED}Args missing or invalid. Service will not be restarted.${RESET}"
  fi
}

duDir() { du -h --max-depth=1 "${@:-.}" 2>/dev/null | sort -h; }

makeRPM() {
  local fpm='/usr/bin/env fpm'

  local m='ops@solutionreach.com'
  local t='rpm'
  local s='dir'
  local os='linux'
  local C='./'
  local p='./'
  local v='1.0.0'

  read -ep "Package type {rpm}: " t_cust
  read -ep "Source type {dir}: " s_cust
  read -ep "Target OS {linux}:" os_cust
  read -ep "Package name: " n
  read -ep "Package version {1.0.0}: " v_cust
  read -ep "Package vendor: " vendor
  read -ep "Package url: " url
  read -ep "Package summary (description): " summary
  read -ep "Chdir path (source path) {./}: " C_cust
  read -ep "Package prefix (dest path): " prefix
  read -ep "Package file output path {./}: " p_cust
  read -ep "Maintainer {ops@}: " m_cust

  echo -e "fpm command:\n"
  cat <<EOF
${fpm} -t ${t_cust:-$t} -s ${s_cust:-$s} --force \
    -n ${n} -v ${v_cust:-$v} -m ${m_cust:-$m} --url ${url:-\'\'} \
    --vendor ${vendor:-\'\'} --rpm-os ${os_cust:-$os} --rpm-summary "${summary}" \
    --prefix ${prefix} -C ${C_cust:-$C} -p ${p_cust:-$p}
EOF
  echo -e "\nCreating package file..."
  ${fpm} -t ${t_cust:-$t} -s ${s_cust:-$s} --force \
    -n ${n} -v ${v_cust:-$v} -m ${m_cust:-$m} --url ${url:-\'\'} \
    --vendor ${vendor:-\'\'} --rpm-os ${os_cust:-$os} --rpm-summary "${summary}" \
    --prefix ${prefix} -C ${C_cust:-$C} -p ${p_cust:-$p}
}

genTFA() { echo -n "$(lpass show -pG ad_pass)$(oauth --account sr)"; }

unzipDir() {
  local file="$@"
  testZipDir() {
    local zipDir=${1}
    if [[ -e "${zipDir}" ]]; then
      echo "${RED}File or Directory \"${zipDir}\" already exists${RESET}"
      echo "${YELLOW}Replace?${RESET}"
      if ! menu no yes; then
        mv -v "${zipDir}" "${zipDir}.bak"
        return 0
      else
        echo "${YELLOW}Skipping unzip process of \"${zipDir}\"${RESET}"
        return 1
      fi
    else
      return 0
    fi
  }
  local zipDir="./${file%.zip}"
  if testZipDir "${zipDir}"; then
    mkdir -v "${zipDir}"
    echo "${BLUE}Unzipping file to directory \"${zipDir}\"...${RESET}"
    unzip "${file}" -d "${zipDir}"
  fi
}

openTEMPLATE() {
  local templateDirectory variableFormat availableTemplateTypes availableTemplates templateFile templateType projectFile templateVars var subProj

  templateDirectory=~/.config/Sublime/templates variableFormat='%VAR%'
  echo "${templateDirectory}"
  availableTemplateTypes=($(find "${templateDirectory}" -maxdepth 1 -mindepth 1 -type d ! -empty))
  echo "${B} What type of template would you like to open?${RS}"
  menu ${availableTemplateTypes[*]##*/}
  templateType=${availableTemplateTypes[$?]} availableTemplates=($(find -L "${templateType}" -type f -iname "*.template"))
  echo "${B} What template would you like to open? ${RS}"
  menu ${availableTemplates[*]##*/}
  templateFile=${availableTemplates[$?]}
  [[ -f ${templateFile%.*}.sublime-project ]] && projectFile="--project ${templateFile%.*}.sublime-project"
  projectFile=$(sed -E 's/^(.*\/)(.*)\.[a-z]*$/\1.\2.sublime-project/' <<<${templateFile})
  [[ -f ${projectFile} ]] && subProj="--project ${projectFile}"
  templateVars=($(grep -o -E '%[A-Z0-9]*%' ${templateFile} | tr -d % | sort -u))
  for var in ${templateVars[*]}; do
    read -ep "What value would you like to assign to ${Y}'${var}'${RS}: " ${var}
  done
  sed "$(for var in ${templateVars[*]}; do echo -n "s|%${var}%|${!var}|g;"; done)" ${templateFile} | subl ${subProj} -
}

dnsDate() {
  local zoneFile=${1:-communitect.com} nSerial cSerial
  cSerial=$(grep --color=never -m1 -E -o "[0-9]{10}" ${zoneFile}) nSerial=$(date '+%Y%m%d00')
  ((cSerial >= nSerial)) && nSerial=$((cSerial + 1))
  perl -i -pe "s/\d{10}/${nSerial}/" ${zoneFile} && echo "Serial for ${zoneFile} has been changed from ${cSerial} -> ${nSerial}."
}

processTime() {
  if [[ -n $(perl -pe 's/[a-z]//gi' <<<${1}) ]]; then
    local refresh=${1}
    shift
  fi
  local UP=$(tput cuu1)
  local E=$(tput el) local EL=${UP}${E}
  while true; do
    printf "\n%30s\n" " " | tr " " "-"
    echo "Elapsed Time: $(ps -p $(pidof "$@" 2>/dev/null) -o etime= 2>/dev/null)"
    printf "%30s\n\n" " " | tr " " "-"
    sleep ${refresh:-2.5}
    echo -ne "${EL}${EL}${EL}${EL}${EL}"
  done
}

hostAlive() {
  local status host=${1:-8.8.8.8} UP=$(tput cuu1) E=$(tput el)
  while true; do
    if ping -c 1 -W 1500 "${host}" &>/dev/null; then
      status="${GREEN}Host: Alive${RESET} (${host})"
    else
      status="${RED}Host: Unreachable${RESET} (${host})"
    fi
    printf "\n%30s\n"${E} " " | tr " " "-"
    echo "${E}${status}"
    printf "%30s\n\n"${E} " " | tr " " "-"
    echo "${UP}${UP}${UP}${UP}${UP}${UP}"
    sleep 2
  done
}

filePath() { printf %q "$(pwd)/$*"; }
cpFilePath() { filePath "$*" | pbcopy; }

sanitizeFilePaths() {
  local tgtDir="${1%/}"
  [[ -z ${tgtDir} ]] && echo "NO PATH PROVIDED" && return
  local destDir="$(sed 's/^\.\///;s/^\.//;s/\/$//' <<<"${tgtDir}")_stripped"
  local IFS=$'\n'
  local ogFiles=($(find "${tgtDir}" -type f ! -iname ".*" | sed 's/\.\///g;s/\/\//\//g'))
  local files=($(echo "${ogFiles[*]}" | perl -pe 's/(\.?\/) +(.*?)/$1$2/g;s/(.*?) +(\/)/$1$2/g'))
  local newDirs=($(for file in "${files[@]}"; do dirname "${file}"; done | sort -u))
  for dir in ${newDirs[@]}; do
    mkdir -pv "${destDir}/${dir/\.\//}"
  done
  echo "${Y}PREVIEW OF CHANGES${RS}"
  local i=0
  for file in "${ogFiles[@]}"; do
    echo "'${file}' -> '${destDir}/${files[${i}]}'"
    ((i++))
  done

  echo "${B}Continue?${RS}"
  if menu no yes; then
    rm -vrf "${destDir}"
  else
    local i=0
    for file in "${ogFiles[@]}"; do
      mv -v "${file}" "${destDir}/${files[${i}]}"
      ((i++))
    done
  fi
}

cleanDupes() {
  local IFS=$'\n' fileList="$(find . \! -type d -exec md5 -r {} \; | sort -k1)"
  local hashDupes=($(cut -d' ' -f1 <<<"${fileList}" | uniq -d))
  for hash in ${hashDupes[*]}; do
    local oc rmList dupes=($(grep "${hash}" <<<"${fileList}" | perl -pe 's/^.*? //g;s/\ /\\ /g' | xargs ls -1cr))
    echo -e "${BLUE}Which file would you like to keep? (Files are listed oldest to newest)${RS}"
    menu ${dupes[*]} SKIP
    oc=$?
    ((oc == ${#dupes[*]})) && continue
    rmList=($(sed $((oc + 1))d <<<"${dupes[*]}"))
    echo
    rm -v "${rmList[@]// /\ }"
    echo -e "\n\n"
  done
}

sortMedia() {
  local mediaDir="${1:?No path specified}"
  echo "${Y}Moving media from ${mediaDir} to $(pwd)/Videos and $(pwd)/Images.${RS}"
  echo "Proceed?"
  menu no yes && return
  mkdir -p ./Videos ./Images
  echo "${G}Relocating all images...${RS}"
  find "${mediaDir}" -name '*' -exec file {} \; | grep -i -o -E '^.+: \w+ image' | cut -d: -f1 | sed 's/ /\\ /g' | xargs mv -v -t ./Images/
  echo "${G}Relocating all videos...${RS}"
  find "${mediaDir}" -name '*' -exec file {} \; | grep -i -o -E '^.+: \w+ media' | cut -d: -f1 | sed 's/ /\\ /g' | xargs mv -v -t ./Videos/
}

builtinMan() { man bash | less -p "^(${1}|${1^^})"; }

checkCERT() {
  read -ep "Path to public cert: " pubPath
  read -ep "Path to key: " keyPath

  local pubHash=$(openssl x509 -noout -modulus -in ${pubPath} | openssl md5)
  local keyHash=$(openssl rsa -noout -modulus -in ${keyPath} | openssl md5)

  echo "Public Key Hash: ${pubHash}"
  echo "Private Key Hash: ${keyHash}"

  if [[ "${pubHash}" = "${keyHash}" ]]; then
    echo "${G}Keys match${RS}"
  else
    echo "${R}Keys do not match${RS}"
  fi
}

# cleanDupesAuto() {
#         [[ -d ${1} ]] && local srcPath=${1}
#   local IFS=$'\n' fileList="$(find ${srcPath:-.} \! -type d -exec md5sum -t {} \;|sort -k1)"
#   local hashDupes=($(cut -d' ' -f1 <<< "${fileList}"|uniq -d))
#   for hash in ${hashDupes[*]}
#   do
#     local sortFiles=($(grep "${hash}" <<< "${fileList}" | perl -pe 's/^[0-9a-z]+ *//g;s/ /\\ /g' | xargs ls -S1 | awk '{ print length, $0 }' | sort -n -s | cut -d" " -f2-))
#     local rmFiles=($(echo "${sortFiles[*]}" | tail -n+2))

#     rm -v "${rmFiles[@]// /\ }"
#     echo -e "\n\n"
#   done
# }

cleanDupesAuto() {
  local IFS srcPath hashFile sortedLines hashDupes dupeFiles hash pids
  if [[ -d ${1:-.} ]]; then
    srcPath="${1:-.}"
  else
    echo "ERROR: Provided source path is not a valid directory."
    return 1
  fi
  IFS=$'\n' hashFile="${srcPath}/.hashfile" sortedFile="${srcPath}/.sortedHash" pids=()
  echo >"${hashFile}"
  for file in $(find "${srcPath}" -type f ! -iname ".*"); do
    sudo nice -n -18 md5sum -t "${file}" >>"${hashFile}" 2>/dev/null &
    pids+=($!)
  done &>/dev/null
  for pid in "${pids[@]}"; do
    wait "${pid}" &>/dev/null
  done
  sortedLines="$(sort -k1 -u "${hashFile}")"
  echo "${sortedLines}" >"${hashFile}"
  hashDupes=($(cut -d' ' -f1 "${hashFile}" | uniq -d))
  for hash in "${hashDupes[@]}"; do
    dupeFiles=($(ls -tr $(grep --color=never "${hash}" "${hashFile}" | sed "s/${hash} *//g")))
    # echo "rm -vf -- \"${dupeFiles[@]:1}\""
    rm -vf -- "${dupeFiles[@]:1}"
  done
}

countFiles() {
  [[ -d ${1} ]] && local path=${1}
  du -a ${path:-.} | cut -d/ -f2 | sort | uniq -c | sort -nr | sed '$d'
}

SetSound() {
  local search device
  search="$@"

  device="$(SwitchAudioSource -a | grep -m1 -i "${search}")"

  [[ -n ${device:+x} ]] && SwitchAudioSource -s "${device}"
}

osa() {
  local IFS=$'\n'
  osascript <<EOF
$*
EOF
}

showAlert() {
  osascript <<EOF
tell me to activate
display alert "$*"
EOF
}

gcp() { gcloud compute ssh wordpress${1:+-test} --project=sr-marketing --tunnel-through-iap; }

1pBackupCodes() {
  local IFS=$'\n'
  local opEntry backupCodes backupCode index errorOut
  opEntry="${1}" backupCodes=(${*:2}) index=0 errorOut=0
  [[ -z "${backupCodes[*]}" ]] && backupCodes=($(pbpaste))

  op item get "${opEntry}" &>/dev/null ||
    echo "${R}No 1Password entry found for \"${RS}${opEntry}${R}\"${RS}"

  while ((index < ${#backupCodes[@]})); do
    backupCode=${backupCodes[${index}]}
    ((index++))
    op item edit "${opEntry}" Backup\ Codes.Code\ ${index}[password]="${backupCode}" &>/dev/null || ((errorOut++))
  done

  if ((errorOut > 0)); then
    echo "${R}Failed to add backup code(s) to 1Password entry \"${RS}${opEntry}${R}\"${RS}"
  else
    op item get "${opEntry}"
    echo -e "${G}\n${#backupCodes[@]} backup code(s) have been added to 1Password entry \"${RS}${opEntry}${G}\"${RS}\n"
  fi
}

ncUpload() {
  local opPassRef ncUser ncURL srcPath ncPath

  opPassRef="op://Personal Vault/Nextcloud Personal/CLI Password"
  ncUser="bbrinkerhoff" ncURL="https://bbhoff.ddns.net" srcPath="${1}" ncPath="${2}"

  [[ -z "${srcPath}" ]] && read -ep "Please provide a source path (default './'): " &&
    scrPath="${REPLY:-./}"

  [[ -z "${ncPath}" ]] && read -ep "Please provide a remote path (default '/.Uploads'): " &&
    ncPath="${REPLY:-/.Uploads}"

  printf "Starting Nextcloud file sync from source dir: '${srcPath}' to remote dir: '${ncPath}'..."

  nextcloudcmd --non-interactive --user "${ncUser}" --password "$(op read "${opPassRef}")" \
    --path "${ncPath}" "${srcPath}" "${ncURL}"
}

localFind() {
  local searchDir type IFS
  IFS=$'\n' searchDir="." type="f,d"
  for x in 1 2; do
    case "${1}" in
    b | c | d | p | f | l | s | D | b,* | c,* | d,* | p,* | f,* | l,* | s,* | D,*)
      type="${1}"
      ;;
    *)
      [[ -n "${1}" ]] && searchDir="${1}"
      ;;
    esac
    shift
  done
  for x in $(find "${searchDir}" -maxdepth 1 -type ${type} ! -name "." ${@} -printf '%p\n' | sort); do
    [[ -d "${x}" ]] && ls --color=auto -A -d "${x}" || ls --color=auto "${x}"
  done
  return $?
}

subproj() {
  local proj projs IFS
  IFS=$'\n' projs=($(find ~/.config/Sublime/Packages/User/Projects -type f -iname "*.sublime-project"))
  menu ${projs[@]##*/}
  proj="${projs[$?]}"
  subl --project "${proj}"
}

ScriptDebuggerReset() {
  echo "Killing all Script Debugger Instances..."
  osascript -e 'Tell application "Script Debugger" to quit saving no'
  echo "Removing trial data files..."
  \rm -fv ~/.1@xX4D@yytT2\"\!2\&1#a
  \rm -fv ~/Library/Application\ Support/.1@xX4D@yytT2\"\!2\&1#a
  \rm -fv ~/Library/Application\ Support/../Preferences/.2xbG4@@Ght01%\!020#u
  \rm -frv ~/Library/Application\ Support/Script\ Debugger\ 8.bak
  mv -v ~/Library/Application\ Support/Script\ Debugger\ 8{,.bak}
  echo "Re-launching Script Debugger..."
  open -a "Script Debugger"
}

SpoofMacAddress() {
  local IFS int wifiEnabled allInts targetInt targetIntName action actions
  IFS=$'\n' actions=(randomize reset) allInts=($(networksetup -listallhardwareports | sed '/Hardware Port:/!d;s/.*://g' | sort))

  if [[ -n ${1} ]]; then
    action="${1}"
  else
    echo "${B}What action would you like to perform?${RS}"
    menu ${actions[@]}
    action=${actions[$?]}
  fi

  echo "${B}Which interface would you like to ${action} the MAC address on?${RS}"
  menu "${allInts[@]}"
  targetIntName="${allInts[$?]}"
  targetInt="$(networksetup -listallhardwareports | grep -A1 "${targetIntName}" | sed '/Device:/!d;s/.*: //g')"

  spoof-mac --wifi list | grep -q "\"${targetInt}\"" && wifiEnabled=true

  [[ ${wifiEnabled} == true ]] && networksetup -setairportpower "${targetInt}" off
  echo "${Y}Performing ${action} on interface ${targetInt}...${RS}"
  if sudo spoof-mac "${action}" "${targetInt}" &>/dev/null; then
    echo "${G}Successfully performed ${action} on interface ${targetInt}!${RS}"
  else
    echo "${R}Failed to perform ${action} on interface ${targetInt}.${RS}"
  fi
  [[ ${wifiEnabled} == true ]] && networksetup -setairportpower "${targetInt}" on
}

isValidIP() {
  local ip stat IFS
  ip="${@}" stat=1

  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    IFS='.' read -r -a octet <<<"${ip}"
    [[ ${octet[0]} -le 255 && ${octet[1]} -le 255 && ${octet[2]} -le 255 && ${octet[3]} -le 255 ]]
    stat=$?
  fi
  return ${stat}
}

openSublimeProject() {
  local wsJson wsPath projDir projPath projName
  projName="${1}"
  projDir=~/.config/Sublime/Packages/User/Projects
  projPath="${projDir}/${projName}.sublime-project"
  wsPath="${projDir}/${projName}.sublime-workspace"
  if [[ -n "${2}" ]]; then
    wsJson="$(jq '."expanded_folders" = []' "${wsPath}")"
    echo "${wsJson}" >"${wsPath}"
  fi
  subl --project "${projPath}"
}

pruneGitBranches() {
  local flag branches branch IFS
  [[ -n "${1:+x}" ]] && flag=list
  branches=($(git branch --${flag:-merged} | sed -E '/^\*? *master$/d'))
  IFS=,
  [[ -z ${branches[@]} ]] && echo "${Y}No branches found to be pruned.${RS}" && return
  echo "'Removing the following branches': [${branches[*]}]" | yq -P
  echo -e "\n${Y}Continue?${RS}"
  unset IFS
  menu no yes && return
  echo
  git branch -vD ${branches[@]} && echo -e "\n${G}Successfully pruned git branches!${RS}" ||
    echo -e "\n${R}Failed to prune git branches.${RS}"
}

dlSong() {
  local URL format
  URL="${1}" format="$(ytdlp-plugins -F "${URL}" | grep -E 'mp3 *audio' -m1 | awk '{print $1}')"
  ytdlp-plugins --format "${format}" "${URL}"
}

rmSSH() { [[ -n $@ ]] && sed -i "/^$@ /d" ${HOME}/.ssh/known_hosts; }

showBASHEnv() { (PS4='+$BASH_SOURCE> ' BASH_XTRACEFD=7 bash -xl -c 'true' 7>&1); }

extractVideoFrames() {
  local video="${@}"
  mkdir -pv "./${video}_frames"
  ffmpeg -i "${video}" -pix_fmt rgba "${video}_frames/frame_%04d.png"
}

pasteScript() {
  local script scriptname
  script="$(pbpaste)"
  read -ep "Script name: " scriptname
  echo "${script}" >"${scriptname}"
  chmod +x "${scriptname}"
}
